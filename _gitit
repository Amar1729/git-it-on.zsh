#compdef gitit

# TODO TODO TODO - none of the stuff in this script is wrapped in the proper way of doing autocompletions
# primarily, it dirties up global ns something awful
# this should all be cleaned (reference completions from a real tool like git/tmux) before pull req

typeset -ga _gitit_commands

# TODO - unset this after completion script
CACHE_FILE='/tmp/gitit_user_cache'
[[ ! -f $CACHE_FILE ]] && touch $CACHE_FILE

# --- Utility functions ---
# They should be called __gitit-*() and kept separate from the
# sub-command functions.

function __gitit-cache {
    # i don't think this is the best way to check arguments, but it's all i have for now
    [[ -z "$1" ]] && return 0
    [[ -z "$2" ]] && return 0
    echo "$1=($2)" >> $CACHE_FILE
}

function __gitit-cached-users {
    local USERS=($(cat $CACHE_FILE 2>/dev/null | cut -f1 -d '='))
    echo $USERS
}

function __gitit-cached-repos {
    # TODO - there maybe should be timestamps for each username so polling can
    # be independent of file mod time?

    # put this here for now
    # (if cachefile is deleted while a terminal is open, it won't be recreated at _gitit init)
    [[ ! -f $CACHE_FILE ]] && touch $CACHE_FILE

    # Check how old cachefile is. if it's >24 hours, re-poll
    # TODO - this only works for the first repoll each day
    if test `find $CACHE_FILE -mmin +1440`; then
        # remove old info if it's there
        sed -i -e "/^$1=/d" $CACHE_FILE
        return 1
    fi

    if grep "^$1=" $CACHE_FILE > /dev/null; then
        source $CACHE_FILE
        local REPOS=($(eval "echo \$$1"))
        echo $REPOS
    else
        return 1
    fi
}

function __gitit-repos {
    ENDPOINT="https://api.github.com/users/$1/repos"
    PARAMS="?per_page=100&sort=updated"
    local REPOS=($(curl "${ENDPOINT}${PARAMS}" 2>/dev/null | jq '.[] | .name' | tr -d '"'))
    echo $REPOS
}

#### gitit commands and subcommands

function _gitit {

    # this almost works!
    #_alternative __gitit-bare -- __gitit-subcmd
    _arguments -C \
        '1:file:__gitit-bare'

    _arguments -C \
        '1:subcmd:__gitit-subcmd'

    # if the second word is completed, check if it's a subcommand or filename
    if [[ -n ${words[2]} ]]; then

        if [[ -n "${_gitit_commands[(r)${words[2]}:*]}" ]]; then
            # start subcommand completions
            __gitit-subcmd
        else
            # no argument usage: gitit <file> [<branch>]
            __gitit-bare
        fi

    fi
}

function __gitit-bare {
    _arguments \
        ':files:_files' \
        ':branch:_gitit-branch'
}

# technically a utility function, but this manages the subcommand description
# generation and all completions for subcommands
function __gitit-subcmd {
    local context state state_descr line
    typeset -A opt_args

    local gitit_describe=

    _arguments -C \
        "*::subcommand:->subcommand"

    if [[ ${state} == "subcommand" ]]; then
        if (( CURRENT == 1 )); then
            # (from tmux) wtf is this for?
            #zstyle -s ":completion:${curcontext}:subcommands" mode mode || mode='both'
            _describe -t commands 'commands' _gitit_commands
        else
            # should change to this eventually? :
            # _call_function ret ${gititcmd}
            _gitit-${words[1]}
        fi
    fi

    return 0
}

# --- Sub-command functions ---
# These functions provide completion for gitit subommands
# They MUST be named as _gitit-<subcmd>
# They all must check $gitit_describe, print a description,
# and return if it's nonempty.
# Other utility functions should be named __gitit-*

function _gitit-branch {
    [[ -n ${gitit_describe} ]] && print "open particular branch" && return

    # eventual TODO - add remotes as candidates when that functionality is added to gitit
    local -a _branches
    for br in $(git rev-parse --abbrev-ref --remotes); do
        local desc="${br#*/}${br:+:$br}"
        if [[ ! ${_branches[(r)${desc}]} == ${desc} ]]; then
            _branches+=( ${desc} )
        fi
    done

    _describe -t arguments 'arguments' _branches
}

function _gitit-repo {
    [[ -n ${gitit_describe} ]] && print "open repository with user/repo name (requires jq)" && return

    # check for existence of jq!
    if (( ${+commands[jq]} == 0 )); then
        _message '`jq'\'' not found in $path; repo sub-cmd completions disabled.'
        return
    fi

    local context state state_descr line
    typeset -A opt_args

    # complete the username first
    local USERS=($(__gitit-cached-users))
    _arguments -C \
        "1:user:($USERS)" \
        "::arg:->args"

    # if USER is there, complete the repository name
    if [[ ${state} == "args" && -n "${words[2]}" ]]; then
        # lowercase username to make caching easier
        local USER=$(echo ${words[2]} | tr '[:upper:]' '[:lower:]')

        local REPOS
        if ! REPOS=$(__gitit-cached-repos $USER); then
            REPOS=$(__gitit-repos $USER)
            __gitit-cache $USER $REPOS
        fi

        # add repo names as completion candidates
        _arguments "2:repo:($REPOS)"
    fi
}

function _gitit-compare {
    [[ -n ${gitit_describe} ]] && print "opens the compare file between a branch and master" && return

    _arguments ":branches:_gitit-branch"
}

function _gitit-commits {
    [[ -n ${gitit_describe} ]] && print "opens the commits for your current branch" && return

    _arguments ":branches:_gitit-branch"
}

function _gitit-issues {
    [[ -n ${gitit_describe} ]] && print "open the list of issues" && return

    # nothing else to complete!
}

function _gitit-history  {
    [[ -n ${gitit_describe} ]] && print "opens the github history page for a file" && return

    _arguments \
        '1:file:_files' \
        ':branches:_gitit-branch'
}

function _gitit-pulls {
    [[ -n ${gitit_describe} ]] && print "open the list of pull requests for the repo" && return

    # complicated:
    # * `gitit pulls <filters>` -- open with filters (e.g., `is:open`, `author:peterhurford`)
    # * `gitit pulls <number>` -- open PR #number
}

function _gitit-branches {
    [[ -n ${gitit_describe} ]] && print "open up a specific list of branches in the repo" && return

    _alternative '(all active stale mine)'
}

function _gitit-grep  {
    [[ -n ${gitit_describe} ]] && print "opens the github search page for your term" && return

    # nothing else to complete!
}

function _gitit-ctrlp {
    [[ -n ${gitit_describe} ]] && print "opens the github file finder for a branch (default: master)" && return

    _arguments ":branches:_gitit-branch"
}

# _gitit and __gitit-subcmd orchestrate the completions
function _gitit {
    local context state state_descr line
    typeset -A opt_args

    _arguments -C \
        '1:file:_files'

    _arguments -C \
        '1:subcmd:__gitit-subcmd'

    # if the second word is completed, check if it's a subcommand or filename
    if [[ -n ${words[2]} ]]; then

        if [[ -n "${_gitit_commands[(r)${words[2]}:*]}" ]]; then
            # start subcommand completions
            __gitit-subcmd
        else
            # no argument usage: gitit <file> [<branch>]
            _arguments \
                ':files:_files' \
                ':branch:_gitit-branch'
        fi

    fi
}

# description generation - how it works:
# ${(k)functions} gets the keys (names of the) locally defined functions
# ${(M)...:#_gitit-*} matches the functions that begin with '_gitit-'
# i.e. _gitit-branch, _gitit-repo, etc
# Each function prints a "description" line when it's called if
# gitit_describe is a nonempty variable (the first time _gitit is loaded by shell)
# Then each subcommand:description pair is added to the _gitit_commands array
local desc
local gitit_describe
gitit_describe='yes, please'
for f in ${(M)${(k)functions}:#_gitit-*}; do
    desc="$($f)"
    _gitit_commands+=( "${f#_gitit-}${desc:+:$desc}" )
done

_gitit "$@"
