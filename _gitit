#compdef gitit

# TODO TODO TODO - none of the stuff in this script is wrapped in the proper way of doing autocompletions
# primarily, it dirties up global ns something awful
# this should all be cleaned (reference completions from a real tool like git/tmux) before pull req

# TODO - unset this after completion script
# TODO - check for existence earlier, this currently throws a warning first time script is loaded
CACHE_FILE='/tmp/gitit_user_cache'
[[ ! -f $CACHE_FILE ]] && touch $CACHE_FILE

function _cache {
    # i don't think this is the best way to check arguments, but it's all i have for now
    [[ -z "$1" ]] && return 0
    [[ -z "$2" ]] && return 0
    echo "$1=($2)" >> $CACHE_FILE
}

function _cached_users {
    local USERS=($(cat $CACHE_FILE | cut -f1 -d '='))
    echo $USERS
}

function _cached_repos {
    # Check how old cachefile is. if it's >24 hours, re-poll
    # TODO - this only works for the first repoll each day
    if test `find $CACHE_FILE -mmin +1440`; then
        # remove old info if it's there
        sed -i -e "/^$1=/d" $CACHE_FILE
        return 1
    fi

    if grep "^$1=" $CACHE_FILE > /dev/null; then
        source $CACHE_FILE
        local REPOS=($(eval "echo \$$1"))
        echo $REPOS
    else
        return 1
    fi
}

function _repos {
    ENDPOINT="https://api.github.com/users/$1/repos"
    PARAMS="?per_page=100&sort=updated"
    local REPOS=($(curl "${ENDPOINT}${PARAMS}" 2>/dev/null | jq '.[] | .name' | tr -d '"'))
    echo $REPOS
}

#### gitit commands and subcommands

function _gitit {
    local context state state_descr line
    typeset -A opt_args

    local gitit_describe=

    _arguments -C \
        "*::subcommand:->subcommand"

    if [[ ${state} == "subcommand" ]]; then
        if (( CURRENT == 1 )); then
            _describe -t commands 'commands' gitit_commands
        else
            gititcmd="${words[1]}"

            # (temporary) hardcoded:
            local _gf
            case "$gititcmd" in
                branch)
                    _gf="_gitit_branch"
                    ;;
                repo)
                    _gf="_gitit_repo_user"
                    ;;
            esac
            $_gf
            # _call_function ret ${_gf}
        fi
    fi

    return 0
}

function _gitit_branch {
    [[ -n ${gitit_describe} ]] && print "open particular branch" && return

    # TODO - add a describe saying full name of br including remote
    _branches=($(for br in $(git rev-parse --abbrev-ref --remotes); do
        echo "${br#*/}"
    done))

    _arguments "*:branch:($_branches)"
}

function _gitit_repo_user {
    [[ -n ${gitit_describe} ]] && print "open repository with user/repo name" && return

    local context state state_descr line
    typeset -A opt_args

    local USERS=($(_cached_users))
    _arguments \
        "1: :($USERS)" \
        "*::arg:->args"

    # get repos of specific user
    _gitit_repo_user_repos $line[1]
}

function _gitit_repo_user_repos {
    # lowercase username to make caching easier
    local USER=$(echo $1 | tr '[:upper:]' '[:lower:]')

    # TODO - this is not the best way to do this !!!
    # USER must be a completed arg before this completion function is run (it includes an API req)
    [[ -z "$USER" ]] && return 0

    local REPOS
    #local REPOS=$(_cached_repos $USER)
    if ! REPOS=$(_cached_repos $USER); then
        REPOS=$(_repos $USER)
        _cache $USER $REPOS
    fi

    _arguments \
        "1: :($REPOS)"
}

local desc
local gitit_describe
gitit_describe='yes, please'

typeset -ga gitit_commands gitit_commands_tmp
gitit_commands_tmp=(
    _gitit_branch
    _gitit_repo_user
)

# simple description gen
for f in $gitit_commands_tmp; do
    desc="$($f)"
    gitit_commands+=( "${${f#_gitit_}%%_*}${desc:+:$desc}" )
done

_gitit "$@"
