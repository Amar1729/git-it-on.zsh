#compdef gitit

# TODO TODO TODO - none of the stuff in this script is wrapped in the proper way of doing autocompletions
# primarily, it dirties up global ns something awful
# this should all be cleaned (reference completions from a real tool like git/tmux) before pull req

typeset -ga _gitit_commands

# TODO - unset this after completion script
CACHE_FILE='/tmp/gitit_user_cache'
[[ ! -f $CACHE_FILE ]] && touch $CACHE_FILE

function __gitit-cache {
    # i don't think this is the best way to check arguments, but it's all i have for now
    [[ -z "$1" ]] && return 0
    [[ -z "$2" ]] && return 0
    echo "$1=($2)" >> $CACHE_FILE
}

function __gitit-cached-users {
    local USERS=($(cat $CACHE_FILE 2>/dev/null | cut -f1 -d '='))
    echo $USERS
}

function __gitit-cached-repos {
    # TODO - there maybe should be timestamps for each username so polling can
    # be independent of file mod time?

    # put this here for now
    # (if cachefile is deleted while a terminal is open, it won't be recreated at _gitit init)
    [[ ! -f $CACHE_FILE ]] && touch $CACHE_FILE

    # Check how old cachefile is. if it's >24 hours, re-poll
    # TODO - this only works for the first repoll each day
    if test `find $CACHE_FILE -mmin +1440`; then
        # remove old info if it's there
        sed -i -e "/^$1=/d" $CACHE_FILE
        return 1
    fi

    if grep "^$1=" $CACHE_FILE > /dev/null; then
        source $CACHE_FILE
        local REPOS=($(eval "echo \$$1"))
        echo $REPOS
    else
        return 1
    fi
}

function __gitit-repos {
    # safety checks
    # TODO - actually make sure these safety checks work!
    #[[ -z "$1" ]] && return 0 # i dont think this one is necessary
    if ! $(which jq > /dev/null); then return 0; fi

    ENDPOINT="https://api.github.com/users/$1/repos"
    PARAMS="?per_page=100&sort=updated"
    local REPOS=($(curl "${ENDPOINT}${PARAMS}" 2>/dev/null | jq '.[] | .name' | tr -d '"'))
    echo $REPOS
}

#### gitit commands and subcommands

function _gitit {
    local context state state_descr line
    typeset -A opt_args

    local gitit_describe=

    _arguments -C \
        "*::subcommand:->subcommand"

    if [[ ${state} == "subcommand" ]]; then
        if (( CURRENT == 1 )); then
            # (from tmux) wtf is this for?
            #zstyle -s ":completion:${curcontext}:subcommands" mode mode || mode='both'
            _describe -t commands 'commands' _gitit_commands
        else
            local gititcmd="_gitit-${words[1]}"
            $gititcmd
            # should change to this eventually? :
            # _call_function ret ${gititcmd}
        fi
    fi

    return 0
}

# --- Sub-command functions ---
# These functions provide completion for gitit subommands
# They MUST be named as _gitit_<subcmd>
# They all must check $gitit_describe, print a description,
# and return if it's nonempty.
# Other utility functions should be named __gitit-*

function _gitit-branch {
    [[ -n ${gitit_describe} ]] && print "open particular branch" && return

    # TODO - add a describe saying full name of br including remote
    _branches=($(for br in $(git rev-parse --abbrev-ref --remotes); do
        echo "${br#*/}"
    done))

    _arguments ":branch:($_branches)"
}

function _gitit-repo {
    [[ -n ${gitit_describe} ]] && print "open repository with user/repo name" && return

    local context state state_descr line
    typeset -A opt_args

    # complete the username first
    local USERS=($(__gitit-cached-users))
    _arguments -C \
        "1: :($USERS)" \
        "::arg:->args"

    # if USER is there, complete the repository name
    if [[ ${state} == "args" && -n "${words[2]}" ]]; then
        # lowercase username to make caching easier
        local USER=$(echo ${words[2]} | tr '[:upper:]' '[:lower:]')

        local REPOS
        if ! REPOS=$(__gitit-cached-repos $USER); then
            REPOS=$(__gitit-repos $USER)
            __gitit-cache $USER $REPOS
        fi

        # add repo names as completion candidates
        _alternative "($REPOS)"
    fi
}

# description generation - how it works:
# ${(k)functions} gets the keys (names of the) locally defined functions
# ${(M)...:#_gitit-*} matches the functions that begin with '_gitit-'
# i.e. _gitit-branch, _gitit-repo, etc
# Each function prints a "description" line when it's called if
# gitit_describe is a nonempty variable (the first time _gitit is loaded by shell)
# Then each subcommand:description pair is added to the _gitit_commands array
local desc
local gitit_describe
gitit_describe='yes, please'
for f in ${(M)${(k)functions}:#_gitit-*}; do
    desc="$($f)"
    _gitit_commands+=( "${f#_gitit-}${desc:+:$desc}" )
done

_gitit "$@"
