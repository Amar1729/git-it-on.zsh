#compdef gitit

# store descriptions of possible commands
typeset -ga _gitit_commands

# temporarily store PRs of repo (if `gitit pull' completion is attempted)
typeset -ga _gitit_pulls

# TODO - unset this after completion script
CACHE_FILE='/tmp/gitit_user_cache'
[[ ! -f $CACHE_FILE ]] && touch $CACHE_FILE

# --- Utility functions ---
# They should be called __gitit-*() and kept separate from the
# sub-command functions.

function __gitit-cache {
    # i don't think this is the best way to check arguments, but it's all i have for now
    [[ -z "$1" ]] && return 0
    [[ -z "$2" ]] && return 0
    echo "$1=($2)" >> $CACHE_FILE
}

function __gitit-cached-users {
    local USERS=($(cat $CACHE_FILE 2>/dev/null | cut -f1 -d '='))
    echo $USERS
}

function __gitit-cached-repos {
    # TODO - there maybe should be timestamps for each username so polling can
    # be independent of file mod time?

    # put this here for now
    # (if cachefile is deleted while a terminal is open, it won't be recreated at _gitit init)
    [[ ! -f $CACHE_FILE ]] && touch $CACHE_FILE

    # Check how old cachefile is. if it's >24 hours, re-poll
    # TODO - this only works for the first repoll each day
    if test `find $CACHE_FILE -mmin +1440`; then
        # remove old info if it's there
        sed -i -e "/^$1=/d" $CACHE_FILE
        return 1
    fi

    if grep "^$1=" $CACHE_FILE > /dev/null; then
        source $CACHE_FILE
        local REPOS=($(eval "echo \$$1"))
        echo $REPOS
    else
        return 1
    fi
}

function __gitit-repos {
    ENDPOINT="https://api.github.com/users/$1/repos"
    PARAMS="?per_page=100&sort=updated"
    local result=$(curl "${ENDPOINT}${PARAMS}" 2>/dev/null)

    # checks if user exists
    if [[ $(jq '.message?' <<< ${result} 2>/dev/null) == '"Not Found"' ]]; then
        _message "$1: user does not exist" && return 0
    fi

    local REPOS=($(jq '.[] | .name' <<< ${result} | tr -d '"'))
    echo $REPOS
}

# doesn't cache pulls, but stores them in global _gitit_pulls array
function __gitit-pulls {
    ENDPOINT="https://api.github.com/repos/$1/$2/pulls"
    local result=$(curl "${ENDPOINT}" 2>/dev/null)

    # check length of list of pulls:
    if [[ $(jq '. | length' <<< ${result}) -eq 0 ]]; then
        _message "No pulls to complete" && return 0
    fi

    local hash hash_dec title state number
    for hash in $(jq -r '.[] | @base64' <<< ${result}); do
        hash_dec=$(echo ${hash} | base64 --decode)
        number=$(jq -r '.number' <<< ${hash_dec})
        title=$(jq -r '.title' <<< ${hash_dec})
        state=$(jq -r '.state' <<< ${hash_dec})

        _gitit_pulls+=( "${number}:(${state}) ${title}" )
    done
}

# technically a utility function, but this manages the subcommand description
# generation and all completions for subcommands
function __gitit-subcmd {
    local context state state_descr line
    typeset -A opt_args

    local gitit_describe=

    _arguments -C \
        "*::subcommand:->subcommand"

    if [[ ${state} == "subcommand" ]]; then
        if (( CURRENT == 1 )); then
            # (from tmux) wtf is this for?
            #zstyle -s ":completion:${curcontext}:subcommands" mode mode || mode='both'
            _describe -t commands 'commands' _gitit_commands
        else
            # should change to this eventually? :
            # _call_function ret ${gititcmd}
            _gitit-${words[1]}
        fi
    fi

    return 0
}

# --- Sub-command functions ---
# These functions provide completion for gitit subommands
# They MUST be named as _gitit-<subcmd>
# They all must check $gitit_describe, print a description,
# and return if it's nonempty.
# Other utility functions should be named __gitit-*

function _gitit-branch {
    [[ -n ${gitit_describe} ]] && print "open particular branch" && return

    # eventual TODO - add remotes as candidates when that functionality is added to gitit
    local -a _branches
    for br in $(git rev-parse --abbrev-ref --remotes); do
        local desc="${br#*/}${br:+:$br}"
        if [[ ! ${_branches[(r)${desc}]} == ${desc} ]]; then
            _branches+=( ${desc} )
        fi
    done

    _describe -t arguments 'arguments' _branches
}

function _gitit-repo {
    [[ -n ${gitit_describe} ]] && print "open repository with user/repo name (requires jq)" && return

    # check for existence of jq!
    if (( ${+commands[jq]} == 0 )); then
        _message '`jq'\'' not found in $path; repo sub-cmd completions disabled.'
        return
    fi

    local context state state_descr line
    typeset -A opt_args

    # complete the username first
    local USERS=($(__gitit-cached-users))
    _arguments -C \
        "1:user:($USERS)" \
        "::arg:->args"

    # if USER is there, complete the repository name
    if [[ ${state} == "args" && -n "${words[2]}" ]]; then
        # lowercase username to make caching easier
        local USER=$(echo ${words[2]} | tr '[:upper:]' '[:lower:]')

        local REPOS
        if ! REPOS=$(__gitit-cached-repos $USER); then
            REPOS=$(__gitit-repos $USER)
            __gitit-cache $USER $REPOS
        fi

        # add repo names as completion candidates
        _arguments "2:repo:($REPOS)"
    fi
}

function _gitit-compare {
    [[ -n ${gitit_describe} ]] && print "opens the compare file between a branch and master" && return

    _arguments ":branches:_gitit-branch"
}

function _gitit-commits {
    [[ -n ${gitit_describe} ]] && print "opens the commits for your current branch" && return

    _arguments ":branches:_gitit-branch"
}

function _gitit-issues {
    [[ -n ${gitit_describe} ]] && print "open the list of issues" && return

    # nothing else to complete!
}

function _gitit-history  {
    [[ -n ${gitit_describe} ]] && print "opens the github history page for a file" && return

    _arguments \
        '1:file:_files' \
        ':branches:_gitit-branch'
}

function _gitit-pulls {
    [[ -n ${gitit_describe} ]] && print "open the list of pull requests for the repo" && return

    # check for existence of jq!
    if (( ${+commands[jq]} == 0 )); then
        # TODO - maybe provide filter syntax completion?
        _message '`jq'\'' not found in $path; pull sub-cmd completions disabled.'
        return
    fi

    # complicated:
    # * `gitit pulls <filters>` -- open with filters (e.g., `is:open`, `author:peterhurford`)
    # * `gitit pulls <number>` -- open PR #number

    # so i got this working - no `pulls' defined, then it becomes defined
    # first runthrough, then loop doesn't hapen again. this is almost enough
    # need it to be cleared out if some part of `gitit pulls' is deleted?

    typeset -g _gitit_REPO _gitit_USER # cache previous values to check if user cd'd
    local URL REPO USER

    # get username and reponame
    URL=$(git config --get remote.origin.url)

    if [[ -z $URL ]]; then
        _message "Repository doesn't have a remote"
        return
    fi

    # NOTE - this assumes you can't have / or : in repo/user names
    # delete everything before last slash, delete the possible suffix '.git'
    REPO=${${URL##*/}%.git}
    # delete last slash+word, then delete everything before / or :
    USER=${${${URL%/*}##*/}##*:}

    if [[ $REPO != $_gitit_REPO ]] || [[ $USER != $_gitit_USER ]]; then
        unset _gitit_pulls
        _gitit_REPO=$REPO
        _gitit_USER=$USER
    fi

    if [[ $#_gitit_pulls -eq 0 ]]; then
        __gitit-pulls $USER $REPO
    fi

    _describe -t pull 'pull' _gitit_pulls
}

function _gitit-branches {
    [[ -n ${gitit_describe} ]] && print "open up a specific list of branches in the repo" && return

    _alternative '(all active stale mine)'
}

function _gitit-grep  {
    [[ -n ${gitit_describe} ]] && print "opens the github search page for your term" && return

    # nothing else to complete!
}

function _gitit-ctrlp {
    [[ -n ${gitit_describe} ]] && print "opens the github file finder for a branch (default: master)" && return

    _arguments ":branches:_gitit-branch"
}

# _gitit and __gitit-subcmd orchestrate the completions
function _gitit {
    local context state state_descr line
    typeset -A opt_args

    _arguments -C \
        '1:file:_files'

    _arguments -C \
        '1:subcmd:__gitit-subcmd'

    # if the second word is completed, check if it's a subcommand or filename
    if [[ -n ${words[2]} ]]; then

        if [[ -n "${_gitit_commands[(r)${words[2]}:*]}" ]]; then
            # start subcommand completions
            __gitit-subcmd
        else
            # no argument usage: gitit <file> [<branch>]
            _arguments \
                ':files:_files' \
                ':branch:_gitit-branch'
        fi

    fi
}

# description generation - how it works:
# ${(k)functions} gets the keys (names of the) locally defined functions
# ${(M)...:#_gitit-*} matches the functions that begin with '_gitit-'
# i.e. _gitit-branch, _gitit-repo, etc
# Each function prints a "description" line when it's called if
# gitit_describe is a nonempty variable (the first time _gitit is loaded by shell)
# Then each subcommand:description pair is added to the _gitit_commands array
local desc
local gitit_describe
gitit_describe='yes, please'
for f in ${(M)${(k)functions}:#_gitit-*}; do
    desc="$($f)"
    _gitit_commands+=( "${f#_gitit-}${desc:+:$desc}" )
done

_gitit "$@"
